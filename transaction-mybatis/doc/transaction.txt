Transaction (事务)




事务隔离(Transaction Isolation)
若DBMS支持事务处理，它必须有某种途径来管理2个事务同时对一个数据库进行操作时
可能发生的冲突.用户可指定事务隔离级别，以指明DBMS应该花多大精力来解决潜在的
冲突. 例如，A事务更改了某个值而B事务却在该更改被提交或还原之前读取该值 怎么办.
事务隔离级别越高，为避免冲突所花的精力则越多，java.sql.Connection接口定义了5个
等级，其中最低级别不支持事务，而最高级别则指定当某个事务在对某个数据库进行操作
时，任何其他事务对那个事务正在读取的数据进行任何更改.
通常，隔离级别越高，应用程序执行速度越慢，

事务隔离级别
想要改变一个事务的隔离级别，必须在该事务开始前进行设置，并在事务结束后进行复位，
并不提倡在事务中途对事务隔离级别进行更改，这样会触发commit放的调用，使之前所作
的任何更改变成永久性.

JDBC事务隔离级别
1) TRANSACTION_NONE
不支持事务
2) TRANSACTION_READ_UNCOMMITTED
A事务提交前，B事务就已经可以看到A事务对数据产生的更改.
脏读(dirty read)、不可重复读、幻读 会出现
3) TRANSACTION_READ_COMMITTED
A事务提交后，B事务才能看到A事务对数据产生的更改，可避免脏读.
不可重复读、幻读 会出现
当A事务在进行update操作并没有锁住表，B事务可以读取到A事务提交前的数据，
A事务提交之后，B事务可以读取到A事务更新后的数据.
4) TRANSACTION_REPEATABLE_READ
在A事务中查询数据，不允许去读取其他事务正在update的数据，可以读取到其他事务
在当前时间点所提交的新增数据.
幻读 会出现

5) TRANSACTION_SERIALIZABLE
在A事务中执行数据查询时，不允其他事务对查询表进行修改 (增删改都不允许).
幻读就可以避免了.


脏读(dirty read): 提前读到了其他事务 没有提交 的修改.
TRANSACTION_READ_COMMITED可解决此问题

不可重复读: 同一条记录，在一个事务的多次查询中，结果不相同.
在A事务中，第一次查询5条记录结果集为resultSetA1，而此时在B事务中，修改了这5条记录中的2条，
在A事务中，第二次查询到这5条记录结果集为resultSetA2，这个2个结果中有2条记录是不同的，
这就是不可重复读.
TRANSACTION_REPEATABLE_READ可解决此问题，将被其他事务删除、修改的记录将不会被读取到，
当时其他事务提交的新增数据仍然可以读取到，这就依然会出现幻读.

幻读
一个表中数据有新增，而事务A读取到了其他事务提交的新增，将导致后续的查询结果变大，


银行业务-场景
1) TRANSACTION_READ_UNCOMMITTED 出现
该帐户有100元，
A事务读取到之后，将其修改为80，事务尚未提交；
B事务就读取到了80，这就出现了脏读.

2) TRANSACTION_READ_COMMITTED
该帐户有100元，
A事务读取到之后，将其修改为80，事务尚未提交；
B事务就读取到了100，之后A事务提交了，B事务再次读取，则读到80.

3) TRANSACTION_READ_COMMITTED
在事务A中进行查询时，不允许其他事务对查询的数据表进行修改
4) 


事务与应用程序
1) 应用程序中，单独一个查询方法是不需要事务的，因此
没有为这个方法开启一个事务，所以，仅仅是查询就无需事务.

2) 在一个需要事务的方法中，方法开始后，就开启一个事务，在这个事务中，
可能涉及到查询和DML交叉混合的动作，但是，所有这些动作都是在一个事务
中进行.
3) 在应用程序级别谈事务，逻辑程度相对高，主要是将整体的业务放在一个事务
中进行，这样可以避免异常导致的脏数据入库.

事务在不同层次，会有不同的物理意义，但是其要达到的目标是一直的，就是让一个
操作合理地在一个系统中完成.




