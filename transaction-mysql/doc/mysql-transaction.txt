MySql事务


解决的目标
1) 正在修改若干条数据，事务尚未提交，其他事务变更这若干条数据会如何.
2) 正在修改数据，事务尚未提交，其他事务去变更表的结构(DDL).
3) 正在修改数据整个表的数据，事务尚未提交，其他事务变更某些数据会如何.
4) 锁表时，新增/更新语句的执行情况
一个事务新增数据尚未提交，另一个事务修改该条数据，结果会如何.
(实际效果不是如此: 在隔离级别是可重复读时，另一个事务对该条数据不可见，更新结果是失败.)
(实际效果: 另一个事务在等待锁。具体原因暂时未知)

5) 事务等待超时，例如设置20秒超时.
6) 程序执行异常，一直事务不提交也不回滚，连接释放.
7) 如何避免事务竞争锁，导致死锁，
8) 事务隔离级别
9) 自动提交
10) 数据库的默认值，在数据连接对象中都是可以设置具体的值去覆盖默认值.
11) 手动开启行级、表级锁

场景
1) 事务A修改这条数据未提交，事务B修改同条数据并试图提交(等待)
2) 事务A插入这条数据未提交，事务B修改同条数据并试图提交(等待)
3) 事务A修改某条数据未提交，事务B修改表结构(新增/修改都受影响)并试图提交(等待)
4) 锁表(事务未提交)，事务A修改某条数据并试图提交(等待)
5) 锁表(事务未提交)，事务A插入某条数据并试图提交(等待)
6) 锁表(事务未提交)，事务A修改表结构并试图提交(等待)
7) 事务人为超时不提交 (超时)
8) 事务等待锁超时，未能及时提交(等待)

锁
1.行级锁

2.表级锁

3.乐观锁

4.悲观锁


事务隔离级别
1. 读未提交，引发 脏读 问题.
(问题: 读到其他事务未提交的变更数据)

2. 读已提交，解决 脏读 问题，引发 不可重复读 
(解决: 其他事务未提交的变更数据，不会读到)
(问题: 同一事务中读同一条数据，结果可能不同，其他事务对该条数据的变更会出现)

3.可重复读，解决 不可重复读 问题，引发 幻读问题
(解决: 同一事务中多次读同一条数据，结果相同，其他事务对该条数据的变更不会出现)
(问题: 同一事务中相同查询条件，查询结果可能会增多，即加入了其他事务插入的数据)

4.序列化，解决 幻读问题，降低了并发效率
(解决: 解决了同一事务多次查询问题，其他事务插入的数据不会出现在当前事务查询中)
(问题: 频繁锁表，降低了并发效率)












